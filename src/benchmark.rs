use crate::*;
use serde_json::{self, Value};
use css_bitvector_compiler::BitVector;
#[derive(Debug, Clone)]
pub struct WebLayoutFrameResult {
    pub frame_id: usize,
    pub operation_type: String,
    pub frame_description: String,
    pub nodes_affected: usize,
    pub total_nodes: usize,
    pub incremental_cycles: u64,
    pub full_layout_cycles: u64,
    pub speedup: f64,
    pub incremental_cache_hits: usize,
    pub incremental_cache_misses: usize,
    pub modification_type: ModificationType,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ModificationType {
    Insertion,
    Deletion,
    AttributeChange,
    LayoutRecalculation,
    TreeInitialization,
}

#[derive(Debug, Clone)]
pub struct LayoutFrame {
    pub frame_id: usize,
    pub command_name: String,
    pub command_data: Value,
    pub modification_type: ModificationType,
}

// Include generated CSS processing functions directly
// This will be generated by main.rs
#[cfg(feature = "generated-css")]
include!("generated_css_functions.rs");

#[cfg(not(feature = "generated-css"))]
mod fallback_css_processing {
    use crate::*;
    
    fn count_nodes(node: &HtmlNode) -> usize {
        1 + node
            .children
            .iter()
            .map(|child| count_nodes(child))
            .sum::<usize>()
    }
    
    pub fn process_tree_incremental_with_stats(root: &mut HtmlNode) -> (usize, usize, usize) {
        // Fallback: simple processing without actual CSS matching
        let total = count_nodes(root);
        (total, 0, total) // All cache misses
    }
    
    pub fn process_tree_full_recompute(root: &mut HtmlNode) -> (usize, usize, usize) {
        // Fallback: same as incremental for now
        let total = count_nodes(root);
        (total, 0, total) // All cache misses
    }
}

#[cfg(not(feature = "generated-css"))]
use fallback_css_processing::{process_tree_incremental_with_stats, process_tree_full_recompute};

fn count_nodes(node: &HtmlNode) -> usize {
    1 + node
        .children
        .iter()
        .map(count_nodes)
        .sum::<usize>()
}

fn find_node_by_path_mut<'a>(node: &'a mut HtmlNode, path: &[usize]) -> Option<&'a mut HtmlNode> {
    if path.is_empty() {
        return Some(node);
    }

    let next_index = path[0];
    if next_index < node.children.len() {
        find_node_by_path_mut(&mut node.children[next_index], &path[1..])
    } else {
        None
    }
}

fn json_to_html_node(json: &Value) -> Option<HtmlNode> {
    let name = json["name"].as_str()?.to_string();

    if name.starts_with('#') {
        return None;
    }

    let mut node = HtmlNode::new(&name);

    if let Some(attrs) = json["attributes"].as_object() {
        if let Some(id_val) = attrs.get("id") {
            if let Some(id_str) = id_val.as_str() {
                if !id_str.is_empty() {
                    node.id = Some(id_str.to_string());
                }
            }
        }

        if let Some(class_val) = attrs.get("class") {
            if let Some(class_str) = class_val.as_str() {
                node.classes = class_str
                    .split_whitespace()
                    .map(|s| s.to_string())
                    .collect();
            }
        }
    }

    Some(node)
}

fn parse_web_layout_trace(file_path: &str) -> Vec<LayoutFrame> {
    let content = std::fs::read_to_string(file_path).expect("Failed to read web layout trace file");

    let mut frames = Vec::new();
    for (frame_id, line) in content.lines().enumerate() {
        if line.trim().is_empty() {
            continue;
        }

        match serde_json::from_str::<Value>(line) {
            Ok(command_data) => {
                let command_name = command_data["name"]
                    .as_str()
                    .unwrap_or("unknown")
                    .to_string();

                let modification_type = match command_name.as_str() {
                    "init" => ModificationType::TreeInitialization,
                    "layout_init" => ModificationType::LayoutRecalculation,
                    "add" => ModificationType::Insertion,
                    "replace_value" | "insert_value" => ModificationType::AttributeChange,
                    "recalculate" => ModificationType::LayoutRecalculation,
                    _ => ModificationType::AttributeChange,
                };

                frames.push(LayoutFrame {
                    frame_id,
                    command_name,
                    command_data,
                    modification_type,
                });
            }
            Err(e) => {
                eprintln!("Failed to parse frame {}: {}, error: {}", frame_id, line, e);
            }
        }
    }

    frames
}

fn apply_frame_modifications(tree: &mut HtmlNode, frame: &LayoutFrame) -> usize {
    match frame.command_name.as_str() {
        "init" => {
            if let Some(node_data) = frame.command_data.get("node") {
                if let Some(new_tree) = json_to_html_node(node_data) {
                    *tree = new_tree;
                    tree.init_parent_pointers();
                    return count_nodes(tree);
                }
            }
            0
        }
        "layout_init" => {
            // Don't mark all nodes dirty - this is just a layout initialization
            // Only mark root dirty to trigger a single-pass layout
            tree.mark_dirty();
            count_nodes(tree)
        }
        "add" => {
            let path = extract_path_from_command(&frame.command_data);
            if let Some(parent) = find_node_by_path_mut(tree, &path) {
                if let Some(node_data) = frame.command_data.get("node") {
                    if let Some(new_child) = json_to_html_node(node_data) {
                        parent.children.push(new_child);
                        parent.mark_dirty();
                        parent.init_parent_pointers();
                        return 1;
                    }
                }
            }
            0
        }
        "replace_value" | "insert_value" => {
            let path = extract_path_from_command(&frame.command_data);
            if let Some(target_node) = find_node_by_path_mut(tree, &path) {
                if let Some(key) = frame.command_data.get("key").and_then(|k| k.as_str()) {
                    match key {
                        "class" => {
                            if let Some(new_value) =
                                frame.command_data.get("value").and_then(|v| v.as_str())
                            {
                                target_node.classes.clear();
                                for class in new_value.split_whitespace() {
                                    target_node.classes.insert(class.to_string());
                                }
                                target_node.mark_dirty();
                                return 1;
                            }
                        }
                        "id" => {
                            if let Some(new_value) =
                                frame.command_data.get("value").and_then(|v| v.as_str())
                            {
                                target_node.id = if new_value.is_empty() {
                                    None
                                } else {
                                    Some(new_value.to_string())
                                };
                                target_node.mark_dirty();
                                return 1;
                            }
                        }
                        _ => {
                            target_node.mark_dirty();
                            return 1;
                        }
                    }
                }
            }
            0
        }
        "recalculate" => {
            // Don't mark all nodes dirty - this defeats the purpose of incremental processing
            // Only mark root dirty to trigger incremental layout recalculation
            tree.mark_dirty();
            count_nodes(tree)
        }
        _ => 0,
    }
}

fn extract_path_from_command(command_data: &Value) -> Vec<usize> {
    command_data
        .get("path")
        .and_then(|p| p.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_u64())
                .map(|v| v as usize)
                .collect::<Vec<_>>()
        })
        .unwrap_or_default()
}

fn mark_all_dirty_for_layout(node: &mut HtmlNode) {
    node.mark_dirty();
    for child in &mut node.children {
        mark_all_dirty_for_layout(child);
    }
}

fn get_frame_description(frame: &LayoutFrame) -> String {
    match frame.command_name.as_str() {
        "init" => "Initialize layout tree from browser DOM".to_string(),
        "layout_init" => "Browser layout initialization".to_string(),
        "add" => {
            let path = extract_path_from_command(&frame.command_data);
            let node_name = frame
                .command_data
                .get("node")
                .and_then(|n| n.get("name"))
                .and_then(|name| name.as_str())
                .unwrap_or("element");
            format!("Insert {} element at depth {}", node_name, path.len())
        }
        "replace_value" => {
            let key = frame
                .command_data
                .get("key")
                .and_then(|k| k.as_str())
                .unwrap_or("property");
            format!("Modify {} attribute/property", key)
        }
        "insert_value" => {
            let key = frame
                .command_data
                .get("key")
                .and_then(|k| k.as_str())
                .unwrap_or("property");
            format!("Add {} attribute/property", key)
        }
        "recalculate" => "Browser layout recalculation".to_string(),
        _ => "Unknown layout operation".to_string(),
    }
}

fn benchmark_layout_frame(initial_tree: &HtmlNode, frame: &LayoutFrame) -> WebLayoutFrameResult {
    let mut tree_incremental = initial_tree.clone();
    let mut tree_full_layout = initial_tree.clone();

    // Apply modifications to both trees
    let nodes_affected = apply_frame_modifications(&mut tree_incremental, frame);
    apply_frame_modifications(&mut tree_full_layout, frame);

    // WARM-UP PHASE: Establish cached state for incremental processing
    // This is crucial for realistic incremental performance measurement
    // Run incremental layout once to populate caches, then clear dirty flags
    let _ = invoke_incremental_layout(&mut tree_incremental);
    clear_dirty_flags(&mut tree_incremental);
    
    // Re-apply modifications to create realistic dirty state
    apply_frame_modifications(&mut tree_incremental, frame);

    let total_nodes = count_nodes(&tree_incremental);

    // Now measure incremental performance with proper cached state
    let start_incremental = rdtsc();
    let (_, cache_hits, cache_misses) = invoke_incremental_layout(&mut tree_incremental);
    let end_incremental = rdtsc();
    let incremental_cycles = end_incremental - start_incremental;

    // For full layout comparison, clear caches and mark all dirty
    clear_all_layout_cache(&mut tree_full_layout);
    mark_all_dirty_for_layout(&mut tree_full_layout);

    let start_full = rdtsc();
    let _ = invoke_full_layout(&mut tree_full_layout);
    let end_full = rdtsc();
    let full_layout_cycles = end_full - start_full;

    let speedup = if full_layout_cycles > 0 {
        incremental_cycles as f64 / full_layout_cycles as f64
    } else {
        1.0
    };

    WebLayoutFrameResult {
        frame_id: frame.frame_id,
        operation_type: frame.command_name.clone(),
        frame_description: get_frame_description(frame),
        nodes_affected,
        total_nodes,
        incremental_cycles,
        full_layout_cycles,
        speedup,
        incremental_cache_hits: cache_hits,
        incremental_cache_misses: cache_misses,
        modification_type: frame.modification_type.clone(),
    }
}

fn invoke_incremental_layout(tree: &mut HtmlNode) -> (usize, usize, usize) {
    // Use the generated incremental CSS processing code for realistic benchmarks
    process_tree_incremental_with_stats(tree)
}

fn invoke_full_layout(tree: &mut HtmlNode) -> (usize, usize, usize) {
    // Use the generated full layout processing code for realistic benchmarks
    process_tree_full_recompute(tree)
}

fn clear_all_layout_cache(node: &mut HtmlNode) {
    node.cached_parent_state = None;
    node.cached_node_intrinsic = None;
    node.cached_child_states = None;

    for child in &mut node.children {
        clear_all_layout_cache(child);
    }
}

fn clear_dirty_flags(node: &mut HtmlNode) {
    node.is_self_dirty = false;
    node.has_dirty_descendant = false;

    for child in &mut node.children {
        clear_dirty_flags(child);
    }
}

pub fn run_web_browser_layout_trace_benchmark() -> Vec<WebLayoutFrameResult> {
    println!("🌐 Starting Web Browser Layout Trace Benchmark");
    println!("📊 Simulating Ladybird-style layout trace methodology...");
    println!("Loading layout trace from css-gen-op/command.json...");

    let frames = parse_web_layout_trace("css-gen-op/command.json");
    println!("🎬 Found {} layout frames to benchmark", frames.len());
    println!(
        "📈 Each frame represents one data point (like Ladybird's 2216 frames from 50 websites)"
    );

    let mut current_layout_tree = HtmlNode::new("html");
    if let Some(init_frame) = frames.first() {
        if init_frame.command_name == "init" {
            apply_frame_modifications(&mut current_layout_tree, init_frame);
            println!(
                "✅ Initialized layout tree with {} nodes",
                count_nodes(&current_layout_tree)
            );
        }
    }

    let mut results = Vec::new();

    for (i, frame) in frames.iter().enumerate() {
        println!(
            "🎬 Processing frame {}/{}: {} ({})",
            i + 1,
            frames.len(),
            frame.command_name,
            get_frame_description(frame)
        );

        let result = benchmark_layout_frame(&current_layout_tree, frame);

        println!(
            "  📊 Incremental: {} cycles, Full: {} cycles, Speedup: {:.3}x, Cache hits: {}/{}",
            result.incremental_cycles,
            result.full_layout_cycles,
            result.speedup,
            result.incremental_cache_hits,
            result.incremental_cache_hits + result.incremental_cache_misses
        );

        results.push(result);

        apply_frame_modifications(&mut current_layout_tree, frame);
    }

    print_web_layout_trace_summary(&results);

    let csv_content = generate_web_layout_csv(&results);
    if let Err(e) = std::fs::write("web_layout_trace_benchmark.csv", csv_content) {
        eprintln!("Failed to write CSV file: {}", e);
    } else {
        println!("💾 Web layout trace results saved to web_layout_trace_benchmark.csv");
    }

    results
}

fn print_web_layout_trace_summary(results: &[WebLayoutFrameResult]) {
    let total_frames = results.len();
    let avg_speedup = results.iter().map(|r| r.speedup).sum::<f64>() / total_frames as f64;

    let insertions = results
        .iter()
        .filter(|r| r.modification_type == ModificationType::Insertion)
        .count();
    let deletions = results
        .iter()
        .filter(|r| r.modification_type == ModificationType::Deletion)
        .count();
    let attribute_changes = results
        .iter()
        .filter(|r| r.modification_type == ModificationType::AttributeChange)
        .count();
    let layout_recalcs = results
        .iter()
        .filter(|r| r.modification_type == ModificationType::LayoutRecalculation)
        .count();
    let tree_inits = results
        .iter()
        .filter(|r| r.modification_type == ModificationType::TreeInitialization)
        .count();

    let faster_incremental = results.iter().filter(|r| r.speedup < 1.0).count();
    let slower_incremental = results.iter().filter(|r| r.speedup > 1.0).count();
    let similar_performance = results
        .iter()
        .filter(|r| (r.speedup - 1.0).abs() < 0.1)
        .count();

    let total_cache_hits: usize = results.iter().map(|r| r.incremental_cache_hits).sum();
    let total_cache_attempts: usize = results
        .iter()
        .map(|r| r.incremental_cache_hits + r.incremental_cache_misses)
        .sum();
    let overall_cache_hit_rate = if total_cache_attempts > 0 {
        100.0 * total_cache_hits as f64 / total_cache_attempts as f64
    } else {
        0.0
    };

    println!("\n🌐 Web Browser Layout Trace Benchmark Summary:");
    println!("════════════════════════════════════════════════");
    println!("Total layout frames analyzed: {}", total_frames);
    println!("Average speedup (incremental/full): {:.3}x", avg_speedup);

    println!("\n📊 Frame Types (like real web browsing):");
    println!(
        "  Tree initializations: {} ({:.1}%)",
        tree_inits,
        100.0 * tree_inits as f64 / total_frames as f64
    );
    println!(
        "  Node insertions: {} ({:.1}%)",
        insertions,
        100.0 * insertions as f64 / total_frames as f64
    );
    println!(
        "  Node deletions: {} ({:.1}%)",
        deletions,
        100.0 * deletions as f64 / total_frames as f64
    );
    println!(
        "  Attribute changes: {} ({:.1}%)",
        attribute_changes,
        100.0 * attribute_changes as f64 / total_frames as f64
    );
    println!(
        "  Layout recalculations: {} ({:.1}%)",
        layout_recalcs,
        100.0 * layout_recalcs as f64 / total_frames as f64
    );

    println!("\n⚡ Performance Analysis:");
    println!(
        "  Incremental faster: {} ({:.1}%)",
        faster_incremental,
        100.0 * faster_incremental as f64 / total_frames as f64
    );
    println!(
        "  Incremental slower: {} ({:.1}%)",
        slower_incremental,
        100.0 * slower_incremental as f64 / total_frames as f64
    );
    println!(
        "  Similar performance: {} ({:.1}%)",
        similar_performance,
        100.0 * similar_performance as f64 / total_frames as f64
    );

    println!("\n🎯 Cache Efficiency:");
    println!("  Overall cache hit rate: {:.1}%", overall_cache_hit_rate);
    println!("  Total cache hits: {}", total_cache_hits);
    println!("  Total cache attempts: {}", total_cache_attempts);

    println!("\n📈 This benchmark simulates the Ladybird methodology:");
    println!("  ✓ Layout tree dump per frame");
    println!("  ✓ Frame-by-frame diff analysis");
    println!("  ✓ Insertion/deletion/attribute change tracking");
    println!("  ✓ Incremental vs full layout comparison");
    println!("  ✓ Each frame as one data point");
}

fn generate_web_layout_csv(results: &[WebLayoutFrameResult]) -> String {
    let mut csv = String::new();
    csv.push_str("frame_id,operation_type,frame_description,modification_type,nodes_affected,total_nodes,incremental_cycles,full_layout_cycles,speedup,cache_hits,cache_misses,cache_hit_rate\n");

    for result in results {
        let cache_hit_rate = if result.incremental_cache_hits + result.incremental_cache_misses > 0
        {
            100.0 * result.incremental_cache_hits as f64
                / (result.incremental_cache_hits + result.incremental_cache_misses) as f64
        } else {
            0.0
        };

        csv.push_str(&format!(
            "{},{},{},{:?},{},{},{},{},{:.6},{},{},{:.2}\n",
            result.frame_id,
            result.operation_type,
            result.frame_description.replace(",", ";"),
            result.modification_type,
            result.nodes_affected,
            result.total_nodes,
            result.incremental_cycles,
            result.full_layout_cycles,
            result.speedup,
            result.incremental_cache_hits,
            result.incremental_cache_misses,
            cache_hit_rate
        ));
    }

    csv
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_benchmark_with_generated_css() {
        // This test verifies that the benchmark uses actual generated CSS processing
        println!("🧪 Testing benchmark with generated CSS functions");
        
        let benchmark_result = run_web_browser_layout_trace_benchmark();
        
        // Check that we have valid results
        assert!(!benchmark_result.is_empty(), "Should have processed frames");
        assert!(benchmark_result.iter().filter(|r| r.operation_type != "init").count() > 0, "Should have operations");
        assert!(benchmark_result.iter().filter(|r| r.speedup > 0.0).count() > 0, "Should have positive speedup");
        
        println!("✅ Benchmark test passed:");
        println!("   Total frames: {}", benchmark_result.len());
        println!("   Total operations: {}", benchmark_result.iter().filter(|r| r.operation_type != "init").count());
        println!("   Average speedup: {:.3}x", benchmark_result.iter().filter(|r| r.speedup > 0.0).count() as f64 / benchmark_result.len() as f64);
        
        // The fact that we get here means the generated CSS functions are working
        #[cfg(feature = "generated-css")]
        println!("🎯 Using real generated CSS processing functions!");
        
        #[cfg(not(feature = "generated-css"))]
        println!("⚠️  Using fallback CSS processing functions");
    }
}
